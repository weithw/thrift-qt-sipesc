/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace org { namespace ssdut { namespace sipesc { namespace network { namespace types {

struct ResultCode {
  enum type {
    Success = 0,
    TryLater = 1,
    Error = 2
  };
};

extern const std::map<int, const char*> _ResultCode_VALUES_TO_NAMES;

struct SipescErrorCode {
  enum type {
    UNKNOWN = 1,
    PERMISSION_DENIED = 2,
    DATA_REQUIRED = 3,
    INVALID_AUTH = 4,
    AUTH_EXPIRED = 5,
    UNSUPPORTED_OPERATION = 6
  };
};

extern const std::map<int, const char*> _SipescErrorCode_VALUES_TO_NAMES;

struct PrivilegeLevel {
  enum type {
    NORMAL = 1,
    MANAGER = 3,
    ADMIN = 5
  };
};

extern const std::map<int, const char*> _PrivilegeLevel_VALUES_TO_NAMES;

struct TaskStatus {
  enum type {
    NEW = 1,
    RUNNING = 2,
    WAITTING = 3,
    CANCELED = 4,
    DEAD = 5,
    SUCC = 6,
    ERROR = 7,
    WARNING = 8
  };
};

extern const std::map<int, const char*> _TaskStatus_VALUES_TO_NAMES;

typedef int64_t Timestamp;

typedef int64_t Timespan;

typedef std::string Text;

typedef std::string Bytes;

typedef int32_t ID;

class CallResult;

class SipescException;

class Data;

class User;

class PublicUserInfo;

class AuthenticationResult;

class Task;

typedef struct _CallResult__isset {
  _CallResult__isset() : message(false), boolResult(false), byteResult(false), i16Result(false), i32Result(false), i64Result(false), doubleResult(false), strResult(false), binResult(false) {}
  bool message :1;
  bool boolResult :1;
  bool byteResult :1;
  bool i16Result :1;
  bool i32Result :1;
  bool i64Result :1;
  bool doubleResult :1;
  bool strResult :1;
  bool binResult :1;
} _CallResult__isset;

class CallResult {
 public:

  static const char* ascii_fingerprint; // = "76520BBDC91ED82597133CD567017AE3";
  static const uint8_t binary_fingerprint[16]; // = {0x76,0x52,0x0B,0xBD,0xC9,0x1E,0xD8,0x25,0x97,0x13,0x3C,0xD5,0x67,0x01,0x7A,0xE3};

  CallResult(const CallResult&);
  CallResult& operator=(const CallResult&);
  CallResult() : resultCode((ResultCode::type)0), message(), boolResult(0), byteResult(0), i16Result(0), i32Result(0), i64Result(0), doubleResult(0), strResult(), binResult() {
  }

  virtual ~CallResult() throw();
  ResultCode::type resultCode;
  Text message;
  bool boolResult;
  int8_t byteResult;
  int16_t i16Result;
  int32_t i32Result;
  int64_t i64Result;
  double doubleResult;
  std::string strResult;
  std::string binResult;

  _CallResult__isset __isset;

  void __set_resultCode(const ResultCode::type val);

  void __set_message(const Text& val);

  void __set_boolResult(const bool val);

  void __set_byteResult(const int8_t val);

  void __set_i16Result(const int16_t val);

  void __set_i32Result(const int32_t val);

  void __set_i64Result(const int64_t val);

  void __set_doubleResult(const double val);

  void __set_strResult(const std::string& val);

  void __set_binResult(const std::string& val);

  bool operator == (const CallResult & rhs) const
  {
    if (!(resultCode == rhs.resultCode))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.boolResult != rhs.__isset.boolResult)
      return false;
    else if (__isset.boolResult && !(boolResult == rhs.boolResult))
      return false;
    if (__isset.byteResult != rhs.__isset.byteResult)
      return false;
    else if (__isset.byteResult && !(byteResult == rhs.byteResult))
      return false;
    if (__isset.i16Result != rhs.__isset.i16Result)
      return false;
    else if (__isset.i16Result && !(i16Result == rhs.i16Result))
      return false;
    if (__isset.i32Result != rhs.__isset.i32Result)
      return false;
    else if (__isset.i32Result && !(i32Result == rhs.i32Result))
      return false;
    if (__isset.i64Result != rhs.__isset.i64Result)
      return false;
    else if (__isset.i64Result && !(i64Result == rhs.i64Result))
      return false;
    if (__isset.doubleResult != rhs.__isset.doubleResult)
      return false;
    else if (__isset.doubleResult && !(doubleResult == rhs.doubleResult))
      return false;
    if (__isset.strResult != rhs.__isset.strResult)
      return false;
    else if (__isset.strResult && !(strResult == rhs.strResult))
      return false;
    if (__isset.binResult != rhs.__isset.binResult)
      return false;
    else if (__isset.binResult && !(binResult == rhs.binResult))
      return false;
    return true;
  }
  bool operator != (const CallResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CallResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CallResult& obj);
};

void swap(CallResult &a, CallResult &b);

typedef struct _SipescException__isset {
  _SipescException__isset() : why(false) {}
  bool why :1;
} _SipescException__isset;

class SipescException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "24652790C81ECE22B629CB60A19F1E93";
  static const uint8_t binary_fingerprint[16]; // = {0x24,0x65,0x27,0x90,0xC8,0x1E,0xCE,0x22,0xB6,0x29,0xCB,0x60,0xA1,0x9F,0x1E,0x93};

  SipescException(const SipescException&);
  SipescException& operator=(const SipescException&);
  SipescException() : errorCode((SipescErrorCode::type)0), why() {
  }

  virtual ~SipescException() throw();
  SipescErrorCode::type errorCode;
  Text why;

  _SipescException__isset __isset;

  void __set_errorCode(const SipescErrorCode::type val);

  void __set_why(const Text& val);

  bool operator == (const SipescException & rhs) const
  {
    if (!(errorCode == rhs.errorCode))
      return false;
    if (__isset.why != rhs.__isset.why)
      return false;
    else if (__isset.why && !(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const SipescException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SipescException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SipescException& obj);
};

void swap(SipescException &a, SipescException &b);

typedef struct _Data__isset {
  _Data__isset() : size(false), content(false) {}
  bool size :1;
  bool content :1;
} _Data__isset;

class Data {
 public:

  static const char* ascii_fingerprint; // = "FE98095225EE247AF7C97326C83DA597";
  static const uint8_t binary_fingerprint[16]; // = {0xFE,0x98,0x09,0x52,0x25,0xEE,0x24,0x7A,0xF7,0xC9,0x73,0x26,0xC8,0x3D,0xA5,0x97};

  Data(const Data&);
  Data& operator=(const Data&);
  Data() : size(0), content() {
  }

  virtual ~Data() throw();
  int64_t size;
  Bytes content;

  _Data__isset __isset;

  void __set_size(const int64_t val);

  void __set_content(const Bytes& val);

  bool operator == (const Data & rhs) const
  {
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.content != rhs.__isset.content)
      return false;
    else if (__isset.content && !(content == rhs.content))
      return false;
    return true;
  }
  bool operator != (const Data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Data& obj);
};

void swap(Data &a, Data &b);

typedef struct _User__isset {
  _User__isset() : id(false), email(false), name(false), privilege(false), created(false), address(false), comments(false) {}
  bool id :1;
  bool email :1;
  bool name :1;
  bool privilege :1;
  bool created :1;
  bool address :1;
  bool comments :1;
} _User__isset;

class User {
 public:

  static const char* ascii_fingerprint; // = "AF74FC75E38208017CE242B35D39C051";
  static const uint8_t binary_fingerprint[16]; // = {0xAF,0x74,0xFC,0x75,0xE3,0x82,0x08,0x01,0x7C,0xE2,0x42,0xB3,0x5D,0x39,0xC0,0x51};

  User(const User&);
  User& operator=(const User&);
  User() : id(0), userName(), email(), name(), privilege((PrivilegeLevel::type)0), created(0), address(), comments() {
  }

  virtual ~User() throw();
  ID id;
  std::string userName;
  std::string email;
  std::string name;
  PrivilegeLevel::type privilege;
  Timestamp created;
  std::string address;
  Text comments;

  _User__isset __isset;

  void __set_id(const ID val);

  void __set_userName(const std::string& val);

  void __set_email(const std::string& val);

  void __set_name(const std::string& val);

  void __set_privilege(const PrivilegeLevel::type val);

  void __set_created(const Timestamp val);

  void __set_address(const std::string& val);

  void __set_comments(const Text& val);

  bool operator == (const User & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (!(userName == rhs.userName))
      return false;
    if (__isset.email != rhs.__isset.email)
      return false;
    else if (__isset.email && !(email == rhs.email))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    if (__isset.created != rhs.__isset.created)
      return false;
    else if (__isset.created && !(created == rhs.created))
      return false;
    if (__isset.address != rhs.__isset.address)
      return false;
    else if (__isset.address && !(address == rhs.address))
      return false;
    if (__isset.comments != rhs.__isset.comments)
      return false;
    else if (__isset.comments && !(comments == rhs.comments))
      return false;
    return true;
  }
  bool operator != (const User &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const User & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const User& obj);
};

void swap(User &a, User &b);

typedef struct _PublicUserInfo__isset {
  _PublicUserInfo__isset() : username(false) {}
  bool username :1;
} _PublicUserInfo__isset;

class PublicUserInfo {
 public:

  static const char* ascii_fingerprint; // = "96705E9A3FD7B072319C71653E0DBB90";
  static const uint8_t binary_fingerprint[16]; // = {0x96,0x70,0x5E,0x9A,0x3F,0xD7,0xB0,0x72,0x31,0x9C,0x71,0x65,0x3E,0x0D,0xBB,0x90};

  PublicUserInfo(const PublicUserInfo&);
  PublicUserInfo& operator=(const PublicUserInfo&);
  PublicUserInfo() : userId(0), username() {
  }

  virtual ~PublicUserInfo() throw();
  ID userId;
  std::string username;

  _PublicUserInfo__isset __isset;

  void __set_userId(const ID val);

  void __set_username(const std::string& val);

  bool operator == (const PublicUserInfo & rhs) const
  {
    if (!(userId == rhs.userId))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    return true;
  }
  bool operator != (const PublicUserInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PublicUserInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PublicUserInfo& obj);
};

void swap(PublicUserInfo &a, PublicUserInfo &b);

typedef struct _AuthenticationResult__isset {
  _AuthenticationResult__isset() : user(false) {}
  bool user :1;
} _AuthenticationResult__isset;

class AuthenticationResult {
 public:

  static const char* ascii_fingerprint; // = "D91DF35D7C81FB47A9781E890AC24A9C";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0x1D,0xF3,0x5D,0x7C,0x81,0xFB,0x47,0xA9,0x78,0x1E,0x89,0x0A,0xC2,0x4A,0x9C};

  AuthenticationResult(const AuthenticationResult&);
  AuthenticationResult& operator=(const AuthenticationResult&);
  AuthenticationResult() : currentTime(0), authenticationToken(), expiration(0) {
  }

  virtual ~AuthenticationResult() throw();
  Timestamp currentTime;
  std::string authenticationToken;
  Timestamp expiration;
  User user;

  _AuthenticationResult__isset __isset;

  void __set_currentTime(const Timestamp val);

  void __set_authenticationToken(const std::string& val);

  void __set_expiration(const Timestamp val);

  void __set_user(const User& val);

  bool operator == (const AuthenticationResult & rhs) const
  {
    if (!(currentTime == rhs.currentTime))
      return false;
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(expiration == rhs.expiration))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const AuthenticationResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuthenticationResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const AuthenticationResult& obj);
};

void swap(AuthenticationResult &a, AuthenticationResult &b);

typedef struct _Task__isset {
  _Task__isset() : taskId(false), userId(false), createdTime(false), startedTime(false), stopedTime(false), currentTime(false), inputFileNames(false), outputFileNames(false), description(false), status(false), statusComments(false), previousTask(false), nextTask(false) {}
  bool taskId :1;
  bool userId :1;
  bool createdTime :1;
  bool startedTime :1;
  bool stopedTime :1;
  bool currentTime :1;
  bool inputFileNames :1;
  bool outputFileNames :1;
  bool description :1;
  bool status :1;
  bool statusComments :1;
  bool previousTask :1;
  bool nextTask :1;
} _Task__isset;

class Task {
 public:

  static const char* ascii_fingerprint; // = "5BADC010C7F172D895C75A64ED957B83";
  static const uint8_t binary_fingerprint[16]; // = {0x5B,0xAD,0xC0,0x10,0xC7,0xF1,0x72,0xD8,0x95,0xC7,0x5A,0x64,0xED,0x95,0x7B,0x83};

  Task(const Task&);
  Task& operator=(const Task&);
  Task() : taskId(0), userId(0), createdTime(0), startedTime(0), stopedTime(0), currentTime(0), rawCommand(), description(), status((TaskStatus::type)0), statusComments(), previousTask(0), nextTask(0) {
  }

  virtual ~Task() throw();
  ID taskId;
  ID userId;
  Timestamp createdTime;
  Timestamp startedTime;
  Timestamp stopedTime;
  Timestamp currentTime;
  std::string rawCommand;
  std::vector<std::string>  inputFileNames;
  std::vector<std::string>  outputFileNames;
  Text description;
  TaskStatus::type status;
  Text statusComments;
  ID previousTask;
  ID nextTask;

  _Task__isset __isset;

  void __set_taskId(const ID val);

  void __set_userId(const ID val);

  void __set_createdTime(const Timestamp val);

  void __set_startedTime(const Timestamp val);

  void __set_stopedTime(const Timestamp val);

  void __set_currentTime(const Timestamp val);

  void __set_rawCommand(const std::string& val);

  void __set_inputFileNames(const std::vector<std::string> & val);

  void __set_outputFileNames(const std::vector<std::string> & val);

  void __set_description(const Text& val);

  void __set_status(const TaskStatus::type val);

  void __set_statusComments(const Text& val);

  void __set_previousTask(const ID val);

  void __set_nextTask(const ID val);

  bool operator == (const Task & rhs) const
  {
    if (__isset.taskId != rhs.__isset.taskId)
      return false;
    else if (__isset.taskId && !(taskId == rhs.taskId))
      return false;
    if (__isset.userId != rhs.__isset.userId)
      return false;
    else if (__isset.userId && !(userId == rhs.userId))
      return false;
    if (__isset.createdTime != rhs.__isset.createdTime)
      return false;
    else if (__isset.createdTime && !(createdTime == rhs.createdTime))
      return false;
    if (__isset.startedTime != rhs.__isset.startedTime)
      return false;
    else if (__isset.startedTime && !(startedTime == rhs.startedTime))
      return false;
    if (__isset.stopedTime != rhs.__isset.stopedTime)
      return false;
    else if (__isset.stopedTime && !(stopedTime == rhs.stopedTime))
      return false;
    if (__isset.currentTime != rhs.__isset.currentTime)
      return false;
    else if (__isset.currentTime && !(currentTime == rhs.currentTime))
      return false;
    if (!(rawCommand == rhs.rawCommand))
      return false;
    if (__isset.inputFileNames != rhs.__isset.inputFileNames)
      return false;
    else if (__isset.inputFileNames && !(inputFileNames == rhs.inputFileNames))
      return false;
    if (__isset.outputFileNames != rhs.__isset.outputFileNames)
      return false;
    else if (__isset.outputFileNames && !(outputFileNames == rhs.outputFileNames))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.statusComments != rhs.__isset.statusComments)
      return false;
    else if (__isset.statusComments && !(statusComments == rhs.statusComments))
      return false;
    if (__isset.previousTask != rhs.__isset.previousTask)
      return false;
    else if (__isset.previousTask && !(previousTask == rhs.previousTask))
      return false;
    if (__isset.nextTask != rhs.__isset.nextTask)
      return false;
    else if (__isset.nextTask && !(nextTask == rhs.nextTask))
      return false;
    return true;
  }
  bool operator != (const Task &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Task & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Task& obj);
};

void swap(Task &a, Task &b);

}}}}} // namespace

#endif
